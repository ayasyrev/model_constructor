---

title: Title

keywords: fastai
sidebar: home_sidebar

summary: "summary"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/80_test_net.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
    {% raw %}
        
<div class="cell border-box-sizing code_cell rendered">

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># #hide</span>
<span class="c1"># # from nbdev.showdoc import *</span>
<span class="c1"># from fastcore.test import *</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># import torch.nn as nn</span>
<span class="c1"># from collections import OrderedDict</span>
<span class="c1"># from model_constructor.layers import *</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># import torch,math,sys</span>
<span class="c1"># import torch.utils.model_zoo as model_zoo</span>
<span class="c1"># from functools import partial</span>
<span class="c1"># # from fastai.torch_core import Module</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Xresnet-from-fastai-v1">Xresnet from fastai v1<a class="anchor-link" href="#Xresnet-from-fastai-v1">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="helpers">helpers<a class="anchor-link" href="#helpers">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># act_fn = nn.ReLU(inplace=True)</span>

<span class="c1"># # in layers</span>
<span class="c1"># class Flatten(Module):</span>
<span class="c1">#     def forward(self, x): return x.view(x.size(0), -1)</span>

<span class="c1"># def init_cnn(m):</span>
<span class="c1">#     if getattr(m, &#39;bias&#39;, None) is not None: nn.init.constant_(m.bias, 0)</span>
<span class="c1">#     if isinstance(m, (nn.Conv2d,nn.Linear)): nn.init.kaiming_normal_(m.weight)</span>
<span class="c1">#     for l in m.children(): init_cnn(l)</span>

<span class="c1"># def conv(ni, nf, ks=3, stride=1, bias=False):</span>
<span class="c1">#     return nn.Conv2d(ni, nf, kernel_size=ks, stride=stride, padding=ks//2, bias=bias)</span>
<span class="c1"># # in layers</span>
<span class="c1"># def noop(x): return x</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="conv-layer">conv layer<a class="anchor-link" href="#conv-layer">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>

<span class="c1"># def conv_layer(ni, nf, ks=3, stride=1, zero_bn=False, act=True):</span>
<span class="c1">#     bn = nn.BatchNorm2d(nf)</span>
<span class="c1">#     nn.init.constant_(bn.weight, 0. if zero_bn else 1.)</span>
<span class="c1">#     layers = [conv(ni, nf, ks, stride=stride), bn]</span>
<span class="c1">#     if act: layers.append(act_fn)</span>
<span class="c1">#     return nn.Sequential(*layers)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="ResBlock">ResBlock<a class="anchor-link" href="#ResBlock">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v1</span>
<span class="c1"># class ResBlock(Module):</span>
<span class="c1">#     def __init__(self, expansion, ni, nh, stride=1):</span>
<span class="c1">#         nf,ni = nh*expansion,ni*expansion</span>
<span class="c1">#         layers  = [conv_layer(ni, nh, 3, stride=stride),</span>
<span class="c1">#                    conv_layer(nh, nf, 3, zero_bn=True, act=False)</span>
<span class="c1">#         ] if expansion == 1 else [</span>
<span class="c1">#                    conv_layer(ni, nh, 1),</span>
<span class="c1">#                    conv_layer(nh, nh, 3, stride=stride),</span>
<span class="c1">#                    conv_layer(nh, nf, 1, zero_bn=True, act=False)</span>
<span class="c1">#         ]</span>
<span class="c1">#         self.convs = nn.Sequential(*layers)</span>
<span class="c1">#         # TODO: check whether act=True works better</span>
<span class="c1">#         self.idconv = noop if ni==nf else conv_layer(ni, nf, 1, act=False)</span>
<span class="c1">#         self.pool = noop if stride==1 else nn.AvgPool2d(2, ceil_mode=True)</span>

<span class="c1">#     def forward(self, x): return act_fn(self.convs(x) + self.idconv(self.pool(x)))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v2</span>
<span class="c1"># class ResBlock(Module):</span>
<span class="c1">#     def __init__(self, expansion, ni, nh, stride=1, </span>
<span class="c1">#                  conv_layer=conv_layer, act_fn=act_fn,</span>
<span class="c1">#                  pool=nn.AvgPool2d(2, ceil_mode=True)):</span>
<span class="c1">#         nf,ni = nh*expansion,ni*expansion</span>
<span class="c1">#         layers  = [(f&quot;conv_0&quot;, conv_layer(ni, nh, 3, stride=stride)),</span>
<span class="c1">#                    (f&quot;conv_1&quot;, conv_layer(nh, nf, 3, zero_bn=True, act=False))</span>
<span class="c1">#         ] if expansion == 1 else [</span>
<span class="c1">#                    (f&quot;conv_0&quot;,conv_layer(ni, nh, 1)),</span>
<span class="c1">#                    (f&quot;conv_1&quot;,conv_layer(nh, nh, 3, stride=stride)),</span>
<span class="c1">#                    (f&quot;conv_2&quot;,conv_layer(nh, nf, 1, zero_bn=True, act=False))</span>
<span class="c1">#         ]</span>
<span class="c1">#         self.convs = nn.Sequential(OrderedDict(layers))</span>
<span class="c1">#         self.pool = noop if stride==1 else pool</span>
<span class="c1">#         self.idconv = noop if ni==nf else conv_layer(ni, nf, 1, act=False)</span>
<span class="c1">#         self.act_fn =act_fn</span>

<span class="c1">#     def forward(self, x): return self.act_fn(self.convs(x) + self.idconv(self.pool(x)))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># class ResBlock(Module):</span>
<span class="c1">#     def __init__(self, expansion, ni, nh, stride=1, </span>
<span class="c1">#                  conv_layer=conv_layer, act_fn=act_fn,</span>
<span class="c1">#                  pool=nn.AvgPool2d(2, ceil_mode=True), sa=False,sym=False):</span>
<span class="c1">#         nf,ni = nh*expansion,ni*expansion</span>
<span class="c1">#         layers  = [(f&quot;conv_0&quot;, conv_layer(ni, nh, 3, stride=stride)),</span>
<span class="c1">#                    (f&quot;conv_1&quot;, conv_layer(nh, nf, 3, zero_bn=True, act=False))</span>
<span class="c1">#         ] if expansion == 1 else [</span>
<span class="c1">#                    (f&quot;conv_0&quot;,conv_layer(ni, nh, 1)),</span>
<span class="c1">#                    (f&quot;conv_1&quot;,conv_layer(nh, nh, 3, stride=stride)),</span>
<span class="c1">#                    (f&quot;conv_2&quot;,conv_layer(nh, nf, 1, zero_bn=True, act=False))</span>
<span class="c1">#         ]</span>
<span class="c1">#         if sa: layers.append((&#39;sa&#39;, SimpleSelfAttention(nf,ks=1,sym=sym)))</span>
<span class="c1">#         self.convs = nn.Sequential(OrderedDict(layers))</span>
<span class="c1">#         self.pool = noop if stride==1 else pool</span>
<span class="c1">#         self.idconv = noop if ni==nf else conv_layer(ni, nf, 1, act=False)</span>
<span class="c1">#         self.act_fn =act_fn</span>

<span class="c1">#     def forward(self, x): return self.act_fn(self.convs(x) + self.idconv(self.pool(x)))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># ResBlock(1,64,64,sa=True)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># ResBlock(1,64,64,)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="first-vers-XResNet">first vers XResNet<a class="anchor-link" href="#first-vers-XResNet">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # initial version</span>
<span class="c1"># class XResNet(nn.Sequential):</span>
<span class="c1">#     def __init__(self, expansion, layers, c_in=3, c_out=1000):</span>
<span class="c1">#         stem = []</span>
<span class="c1">#         sizes = [c_in,32,32,64]</span>
<span class="c1">#         for i in range(3):</span>
<span class="c1">#             stem.append(conv_layer(sizes[i], sizes[i+1], stride=2 if i==0 else 1))</span>
          
<span class="c1">#         block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         blocks = [self._make_layer(expansion, block_szs[i], block_szs[i+1], l, 1 if i==0 else 2)</span>
<span class="c1">#                   for i,l in enumerate(layers)]</span>
<span class="c1">#         super().__init__(</span>
<span class="c1">#             *stem,</span>
<span class="c1">#             nn.MaxPool2d(kernel_size=3, stride=2, padding=1),</span>
<span class="c1">#             *blocks,</span>
<span class="c1">#             nn.AdaptiveAvgPool2d(1), Flatten(),</span>
<span class="c1">#             nn.Linear(block_szs[-1]*expansion, c_out),</span>
<span class="c1">#         )</span>
<span class="c1">#         init_cnn(self)</span>

<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride):</span>
<span class="c1">#         return nn.Sequential(</span>
<span class="c1">#             *[ResBlock(expansion, ni if i==0 else nf, nf, stride if i==0 else 1)</span>
<span class="c1">#               for i in range(blocks)])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v2</span>
<span class="c1"># class XResNet(nn.Sequential):</span>
<span class="c1">#     def __init__(self, expansion, layers, c_in=3, c_out=1000):</span>
<span class="c1">#         stem = []</span>
<span class="c1">#         sizes = [c_in,32,32,64]</span>
<span class="c1">#         for i in range(3):</span>
<span class="c1">#             stem.append(conv_layer(sizes[i], sizes[i+1], stride=2 if i==0 else 1))</span>
<span class="c1">#              block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         blocks = [self._make_layer(expansion, block_szs[i], block_szs[i+1], l, 1 if i==0 else 2)</span>
<span class="c1">#                   for i,l in enumerate(layers)]</span>
<span class="c1">#         super().__init__(OrderedDict([</span>
<span class="c1">#             (&#39;stem&#39;, nn.Sequential(*stem, nn.MaxPool2d(kernel_size=3, stride=2, padding=1))),</span>
<span class="c1">#             (&#39;body&#39;, nn.Sequential(*blocks)),</span>
<span class="c1">#             (&#39;head&#39;, nn.Sequential(nn.AdaptiveAvgPool2d(1), Flatten(), </span>
<span class="c1">#              nn.Linear(block_szs[-1]*expansion, c_out)))</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(self)</span>

<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride):</span>
<span class="c1">#         return nn.Sequential(</span>
<span class="c1">#             *[ResBlock(expansion, ni if i==0 else nf, nf, stride if i==0 else 1)</span>
<span class="c1">#               for i in range(blocks)])</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v3</span>
<span class="c1"># class XResNet():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion = c_in,c_out,expansion</span>
<span class="c1">#         self.stem = []</span>
<span class="c1">#         sizes = [c_in,32,32,64]</span>
<span class="c1">#         for i in range(3):</span>
<span class="c1">#             self.stem.append(conv_layer(sizes[i], sizes[i+1], stride=2 if i==0 else 1))</span>
<span class="c1">#         self.block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.blocks = [self._make_layer(expansion, self.block_szs[i], self.block_szs[i+1], l, 1 if i==0 else 2)</span>
<span class="c1">#                   for i,l in enumerate(layers)]</span>
        

<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride):</span>
<span class="c1">#         return nn.Sequential(</span>
<span class="c1">#             *[ResBlock(expansion, ni if i==0 else nf, nf, stride if i==0 else 1)</span>
<span class="c1">#               for i in range(blocks)])</span>
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1">#             (&#39;stem&#39;, nn.Sequential(*self.stem, nn.MaxPool2d(kernel_size=3, stride=2, padding=1))),</span>
<span class="c1">#             (&#39;body&#39;, nn.Sequential(*self.blocks)),</span>
<span class="c1">#             (&#39;head&#39;, nn.Sequential(nn.AdaptiveAvgPool2d(1), Flatten(), </span>
<span class="c1">#              nn.Linear(self.block_szs[-1]*self.expansion, self.c_out)))</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v4</span>
<span class="c1"># class XResNet():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion = c_in,c_out,expansion</span>
<span class="c1">#         self.stem = []</span>
<span class="c1">#         sizes = [c_in,32,32,64]</span>
<span class="c1">#         for i in range(3):</span>
<span class="c1">#             self.stem.append(conv_layer(sizes[i], sizes[i+1], stride=2 if i==0 else 1))</span>
<span class="c1">#         self.stem.append(nn.MaxPool2d(kernel_size=3, stride=2, padding=1))</span>
<span class="c1">#         block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.blocks = [self._make_layer(expansion, block_szs[i], block_szs[i+1], l, 1 if i==0 else 2)</span>
<span class="c1">#                   for i,l in enumerate(layers)]</span>
<span class="c1">#         self.head = [nn.AdaptiveAvgPool2d(1), Flatten(), </span>
<span class="c1">#              nn.Linear(block_szs[-1]*self.expansion, self.c_out)]</span>

<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride):</span>
<span class="c1">#         return nn.Sequential(</span>
<span class="c1">#             *[ResBlock(expansion, ni if i==0 else nf, nf, stride if i==0 else 1)</span>
<span class="c1">#               for i in range(blocks)])</span>
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1">#             (&#39;stem&#39;, nn.Sequential(*self.stem)),</span>
<span class="c1">#             (&#39;body&#39;, nn.Sequential(*self.blocks)),</span>
<span class="c1">#             (&#39;head&#39;, nn.Sequential(*self.head))</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v5</span>
<span class="c1"># class XResNet():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion,self.layers = c_in,c_out,expansion,layers</span>
<span class="c1">#         self.stem_sizes = [c_in,32,32,64]</span>
<span class="c1">#         self.block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.block = ResBlock</span>
<span class="c1">#         self.norm = nn.BatchNorm2d</span>
<span class="c1">#         self.act_fn=nn.ReLU(inplace=True)</span>
<span class="c1"># #         self._conv_layer = conv_layer</span>
    
<span class="c1"># #     @property</span>
<span class="c1"># #     def conv_layer(self): return self._conv_layer</span>

<span class="c1">#     def conv_layer(self, ni, nf, ks=3, stride=1, zero_bn=False, act=True):</span>
<span class="c1">#         bn = self.norm(nf)</span>
<span class="c1">#         nn.init.constant_(bn.weight, 0. if zero_bn else 1.)</span>
<span class="c1">#         layers = [(&#39;conv&#39;, conv(ni, nf, ks, stride=stride)), (&#39;norm&#39;, bn)]</span>
<span class="c1">#         if act: layers.append((&#39;act_fn&#39;, self.act_fn))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(layers))</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def stem(self):</span>
<span class="c1">#         return self._make_stem()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def head(self):</span>
<span class="c1">#         return self._make_head()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def body(self):</span>
<span class="c1">#         return self._make_body()</span>
    
<span class="c1">#     def _make_stem(self):</span>
<span class="c1">#         stem = []</span>
<span class="c1">#         for i in range(len(self.stem_sizes)-1):</span>
<span class="c1">#             stem.append((f&quot;conv_{i}&quot;, self.conv_layer(self.stem_sizes[i], self.stem_sizes[i+1], stride=2 if i==0 else 1)))</span>
<span class="c1">#         stem.append((&#39;stem_pool&#39;, nn.MaxPool2d(kernel_size=3, stride=2, padding=1)))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(stem))</span>
    
<span class="c1">#     def _make_head(self):</span>
<span class="c1">#         head = [(&#39;pool&#39;, nn.AdaptiveAvgPool2d(1)),</span>
<span class="c1">#                 (&#39;flat&#39;, Flatten()),</span>
<span class="c1">#                 (&#39;fc&#39;,   nn.Linear(self.block_szs[-1]*self.expansion, self.c_out))]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(head))</span>
    
<span class="c1">#     def _make_body(self):</span>
<span class="c1">#         blocks = [(f&quot;l_{i}&quot;, self._make_layer(self.expansion, </span>
<span class="c1">#                         self.block_szs[i], self.block_szs[i+1], l, 1 if i==0 else 2))</span>
<span class="c1">#                   for i,l in enumerate(self.layers)]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(blocks))</span>
    
<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride):</span>
<span class="c1">#         return nn.Sequential(</span>
<span class="c1">#             *[self.block(expansion, ni if i==0 else nf, nf, </span>
<span class="c1">#                          stride if i==0 else 1,conv_layer=self.conv_layer)</span>
<span class="c1">#               for i in range(blocks)])</span>
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1"># #             (&#39;stem&#39;, nn.Sequential(*self.stem)),</span>
<span class="c1">#             (&#39;stem&#39;, self.stem),</span>
<span class="c1">#             (&#39;body&#39;, self.body),</span>
<span class="c1">#             (&#39;head&#39;, self.head)</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v6</span>
<span class="c1"># class XResNet():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion,self.layers = c_in,c_out,expansion,layers</span>
<span class="c1">#         self.stem_sizes = [c_in,32,32,64]</span>
<span class="c1">#         self.block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.block = ResBlock</span>
<span class="c1">#         self.norm = nn.BatchNorm2d</span>
<span class="c1">#         self.act_fn=nn.ReLU(inplace=True)</span>
<span class="c1">#         self.stem_pool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</span>
<span class="c1">#         self.pool = nn.AvgPool2d(2, ceil_mode=True)</span>
<span class="c1">#         self.sa=False</span>
<span class="c1"># #         self._conv_layer = conv_layer</span>
    
<span class="c1"># #     @property</span>
<span class="c1"># #     def conv_layer(self): return self._conv_layer</span>

<span class="c1">#     def conv_layer(self, ni, nf, ks=3, stride=1, zero_bn=False, act=True):</span>
<span class="c1">#         bn = self.norm(nf)</span>
<span class="c1">#         nn.init.constant_(bn.weight, 0. if zero_bn else 1.)</span>
<span class="c1">#         layers = [(&#39;conv&#39;, conv(ni, nf, ks, stride=stride)), (&#39;norm&#39;, bn)]</span>
<span class="c1">#         if act: layers.append((&#39;act_fn&#39;, self.act_fn))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(layers))</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def stem(self):</span>
<span class="c1">#         return self._make_stem()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def head(self):</span>
<span class="c1">#         return self._make_head()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def body(self):</span>
<span class="c1">#         return self._make_body()</span>
    
<span class="c1">#     def _make_stem(self):</span>
<span class="c1">#         stem = []</span>
<span class="c1">#         for i in range(len(self.stem_sizes)-1):</span>
<span class="c1">#             stem.append((f&quot;conv_{i}&quot;, self.conv_layer(self.stem_sizes[i], self.stem_sizes[i+1], stride=2 if i==0 else 1)))</span>
<span class="c1">#         stem.append((&#39;stem_pool&#39;, self.stem_pool))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(stem))</span>
    
<span class="c1">#     def _make_head(self):</span>
<span class="c1">#         head = [(&#39;pool&#39;, nn.AdaptiveAvgPool2d(1)),</span>
<span class="c1">#                 (&#39;flat&#39;, Flatten()),</span>
<span class="c1">#                 (&#39;fc&#39;,   nn.Linear(self.block_szs[-1]*self.expansion, self.c_out))]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(head))</span>
    
<span class="c1">#     def _make_body(self):</span>
<span class="c1">#         blocks = [(f&quot;l_{i}&quot;, self._make_layer(self.expansion, </span>
<span class="c1">#                         self.block_szs[i], self.block_szs[i+1], l, </span>
<span class="c1">#                         1 if i==0 else 2, self.sa if i==0 else False))</span>
<span class="c1">#                   for i,l in enumerate(self.layers)]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(blocks))</span>
    
<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride,sa):</span>
<span class="c1">#         return nn.Sequential(OrderedDict(</span>
<span class="c1">#             [(f&quot;bl_{i}&quot;, self.block(expansion, ni if i==0 else nf, nf, </span>
<span class="c1">#                     stride if i==0 else 1, sa=sa if i==blocks-1 else False,</span>
<span class="c1">#                     conv_layer=self.conv_layer, act_fn=self.act_fn, pool=self.pool))</span>
<span class="c1">#               for i in range(blocks)]))</span>
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1"># #             (&#39;stem&#39;, nn.Sequential(*self.stem)),</span>
<span class="c1">#             (&#39;stem&#39;, self.stem),</span>
<span class="c1">#             (&#39;body&#39;, self.body),</span>
<span class="c1">#             (&#39;head&#39;, self.head)</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="XResNet">XResNet<a class="anchor-link" href="#XResNet">&#182;</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># # v6</span>
<span class="c1"># class XResNet():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion,self.layers = c_in,c_out,expansion,layers</span>
<span class="c1">#         self.stem_sizes = [c_in,32,32,64]</span>
<span class="c1">#         self.stem_pool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</span>
<span class="c1">#         self.stem_bn_end = False</span>
<span class="c1">#         self.block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.block = ResBlock</span>
<span class="c1">#         self.norm = nn.BatchNorm2d</span>
<span class="c1">#         self.act_fn=nn.ReLU(inplace=True)</span>
<span class="c1">#         self.pool = nn.AvgPool2d(2, ceil_mode=True)</span>
<span class="c1">#         self.sa=False</span>
<span class="c1">#         self.bn_1st = True</span>
<span class="c1">#         #         self._conv_layer = conv_layer</span>
<span class="c1">#         #     @property</span>
<span class="c1">#         #     def conv_layer(self): return self._conv_layer</span>

<span class="c1">#     def conv_layer(self, ni, nf, ks=3, stride=1, zero_bn=False, act=True, norm=True):</span>
<span class="c1">#         bn = self.norm(nf)</span>
<span class="c1">#         nn.init.constant_(bn.weight, 0. if zero_bn else 1.)</span>
<span class="c1">#         layers =  [(&#39;norm&#39;, bn)] if norm else []</span>
<span class="c1">#         if act: layers.append((&#39;act_fn&#39;, self.act_fn))</span>
<span class="c1">#         if not self.bn_1st: layers.reverse()</span>
<span class="c1">#         layers = [(&#39;conv&#39;, conv(ni, nf, ks, stride=stride))] + layers</span>
<span class="c1">#         return nn.Sequential(OrderedDict(layers))</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def stem(self):</span>
<span class="c1">#         return self._make_stem()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def head(self):</span>
<span class="c1">#         return self._make_head()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def body(self):</span>
<span class="c1">#         return self._make_body()</span>
    
<span class="c1">#     def _make_stem(self):</span>
<span class="c1">#         stem = [(f&quot;conv_{i}&quot;, self.conv_layer(self.stem_sizes[i], self.stem_sizes[i+1], </span>
<span class="c1">#                         stride=2 if i==0 else 1, </span>
<span class="c1">#                         norm=(not self.stem_bn_end) if i==(len(self.stem_sizes)-2) else True))</span>
<span class="c1">#                 for i in range(len(self.stem_sizes)-1)]</span>
<span class="c1">#         stem.append((&#39;stem_pool&#39;, self.stem_pool))</span>
<span class="c1">#         if self.stem_bn_end: stem.append((&#39;norm&#39;, self.norm(self.stem_sizes[-1])))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(stem))</span>
    
<span class="c1">#     def _make_head(self):</span>
<span class="c1">#         head = [(&#39;pool&#39;, nn.AdaptiveAvgPool2d(1)),</span>
<span class="c1">#                 (&#39;flat&#39;, Flatten()),</span>
<span class="c1">#                 (&#39;fc&#39;,   nn.Linear(self.block_szs[-1]*self.expansion, self.c_out))]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(head))</span>
    
<span class="c1">#     def _make_body(self):</span>
<span class="c1">#         blocks = [(f&quot;l_{i}&quot;, self._make_layer(self.expansion, </span>
<span class="c1">#                         self.block_szs[i], self.block_szs[i+1], l, </span>
<span class="c1">#                         1 if i==0 else 2, self.sa if i==0 else False))</span>
<span class="c1">#                   for i,l in enumerate(self.layers)]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(blocks))</span>
    
<span class="c1">#     def _make_layer(self, expansion, ni, nf, blocks, stride,sa):</span>
<span class="c1">#         return nn.Sequential(OrderedDict(</span>
<span class="c1">#             [(f&quot;bl_{i}&quot;, self.block(expansion, ni if i==0 else nf, nf, </span>
<span class="c1">#                     stride if i==0 else 1, sa=sa if i==blocks-1 else False,</span>
<span class="c1">#                     conv_layer=self.conv_layer, act_fn=self.act_fn, pool=self.pool))</span>
<span class="c1">#               for i in range(blocks)]))</span>
    
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1">#             (&#39;stem&#39;, self.stem),</span>
<span class="c1">#             (&#39;body&#39;, self.body),</span>
<span class="c1">#             (&#39;head&#39;, self.head)</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v7</span>
<span class="c1"># class Net():</span>
<span class="c1">#     def __init__(self, expansion=1, layers=[2,2,2,2], c_in=3, c_out=1000, name=&#39;Net&#39;):</span>
<span class="c1">#         super().__init__()</span>
<span class="c1">#         self.name = name</span>
<span class="c1">#         self.c_in, self.c_out,self.expansion,self.layers = c_in,c_out,expansion,layers</span>
<span class="c1">#         self.stem_sizes = [c_in,32,32,64]</span>
<span class="c1">#         self.stem_pool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)</span>
<span class="c1">#         self.stem_bn_end = False</span>
<span class="c1">#         self.block_szs = [64//expansion,64,128,256,512] +[256]*(len(layers)-4)</span>
<span class="c1">#         self.block = ResBlock</span>
<span class="c1">#         self.norm = nn.BatchNorm2d</span>
<span class="c1">#         self.act_fn=nn.ReLU(inplace=True)</span>
<span class="c1">#         self.pool = nn.AvgPool2d(2, ceil_mode=True)</span>
<span class="c1">#         self.sa=False</span>
<span class="c1">#         self.bn_1st = True</span>
<span class="c1">#         self.zero_bn=True</span>

<span class="c1">#     def conv_layer(self, ni, nf, ks=3, stride=1, zero_bn=False, act=True, norm=True):</span>
<span class="c1">#         bn = self.norm(nf)</span>
<span class="c1">#         nn.init.constant_(bn.weight, 0. if zero_bn else 1.)</span>
<span class="c1">#         layers =  [(&#39;norm&#39;, bn)] if norm else []</span>
<span class="c1">#         if act: layers.append((&#39;act_fn&#39;, self.act_fn))</span>
<span class="c1">#         if not self.bn_1st: layers.reverse()</span>
<span class="c1">#         layers = [(&#39;conv&#39;, conv(ni, nf, ks, stride=stride))] + layers</span>
<span class="c1">#         return nn.Sequential(OrderedDict(layers))</span>
    
<span class="c1">#     @property</span>
<span class="c1">#     def stem(self):</span>
<span class="c1">#         return self._make_stem()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def head(self):</span>
<span class="c1">#         return self._make_head()</span>
<span class="c1">#     @property</span>
<span class="c1">#     def body(self):</span>
<span class="c1">#         return self._make_body()</span>
    
<span class="c1">#     def _make_stem(self):</span>
<span class="c1">#         stem = [(f&quot;conv_{i}&quot;, self.conv_layer(self.stem_sizes[i], self.stem_sizes[i+1], </span>
<span class="c1">#                         stride=2 if i==0 else 1, </span>
<span class="c1">#                         norm=(not self.stem_bn_end) if i==(len(self.stem_sizes)-2) else True))</span>
<span class="c1">#                 for i in range(len(self.stem_sizes)-1)]</span>
<span class="c1">#         stem.append((&#39;stem_pool&#39;, self.stem_pool))</span>
<span class="c1">#         if self.stem_bn_end: stem.append((&#39;norm&#39;, self.norm(self.stem_sizes[-1])))</span>
<span class="c1">#         return nn.Sequential(OrderedDict(stem))</span>
    
<span class="c1">#     def _make_head(self):</span>
<span class="c1">#         head = [(&#39;pool&#39;, nn.AdaptiveAvgPool2d(1)),</span>
<span class="c1">#                 (&#39;flat&#39;, Flatten()),</span>
<span class="c1">#                 (&#39;fc&#39;,   nn.Linear(self.block_szs[-1]*self.expansion, self.c_out))]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(head))</span>
    
<span class="c1">#     def _make_body(self):</span>
<span class="c1">#         blocks = [(f&quot;l_{i}&quot;, self._make_layer(self.expansion, </span>
<span class="c1">#                         self.block_szs[i], self.block_szs[i+1], l, </span>
<span class="c1">#                         1 if i==0 else 2, self.sa if i==0 else False))</span>
<span class="c1">#                   for i,l in enumerate(self.layers)]</span>
<span class="c1">#         return nn.Sequential(OrderedDict(blocks))</span>
    
<span class="c1">#     def _make_layer(self,expansion,ni,nf,blocks,stride,sa):</span>
<span class="c1">#         return nn.Sequential(OrderedDict(</span>
<span class="c1">#             [(f&quot;bl_{i}&quot;, self.block(expansion, ni if i==0 else nf, nf, </span>
<span class="c1">#                     stride if i==0 else 1, sa=sa if i==blocks-1 else False,</span>
<span class="c1">#                     conv_layer=self.conv_layer, act_fn=self.act_fn, pool=self.pool,zero_bn=self.zero_bn))</span>
<span class="c1">#               for i in range(blocks)]))</span>
    
<span class="c1">#     def __call__(self):</span>
<span class="c1">#         model = nn.Sequential(OrderedDict([</span>
<span class="c1">#             (&#39;stem&#39;, self.stem),</span>
<span class="c1">#             (&#39;body&#39;, self.body),</span>
<span class="c1">#             (&#39;head&#39;, self.head)</span>
<span class="c1">#         ]))</span>
<span class="c1">#         init_cnn(model)</span>
<span class="c1">#         model.extra_repr = lambda : f&quot;model {self.name}&quot;</span>
<span class="c1">#         return model</span>
<span class="c1">#     def __repr__(self):</span>
<span class="c1">#         return f&quot; constr {self.name}&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model  = XResNet()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.stem</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.bn_1st = False</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.act_fn =nn.LeakyReLU(inplace=True)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.sa = True</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.stem_bn_end = True</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># m = model()</span>
<span class="c1"># m</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># bs_test = 16</span>
<span class="c1"># xb = torch.randn(bs_test, 3, 128, 128)</span>
<span class="c1"># y = m(xb)</span>
<span class="c1"># # y.shape</span>
<span class="c1"># print(y.shape)</span>
<span class="c1"># assert y.shape == torch.Size([bs_test, 1000]), f&quot;size expected {bs_test}, 1000&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># m.stem</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># m.body.l_0</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.conv_layer(64,64)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># model.stem_sizes</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="xresnet-constructor">xresnet constructor<a class="anchor-link" href="#xresnet-constructor">&#182;</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # 1 ver </span>
<span class="c1"># def xresnet(expansion, n_layers, name, c_out=1000, pretrained=False, **kwargs):</span>
<span class="c1">#     model = XResNet(expansion, n_layers, c_out=c_out, **kwargs)</span>
<span class="c1"># #     return model</span>
<span class="c1">#     return model()</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # v1</span>
<span class="c1"># me = sys.modules[__name__]</span>
<span class="c1"># for n,e,l in [</span>
<span class="c1">#     [ 18 , 1, [2,2,2 ,2] ],</span>
<span class="c1">#     [ 34 , 1, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 50 , 4, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 101, 4, [3,4,23,3] ],</span>
<span class="c1">#     [ 152, 4, [3,8,36,3] ],</span>
<span class="c1"># ]:</span>
<span class="c1">#     name = f&#39;xresnet{n}&#39;</span>
<span class="c1">#     setattr(me, name, partial(xresnet, expansion=e, n_layers=l, name=name))</span>

<span class="c1"># xresnet18_deep = partial(xresnet, expansion=1, n_layers=[2, 2,  2, 2,1,1], name=&#39;xresnet18_deep&#39;)</span>
<span class="c1"># xresnet34_deep = partial(xresnet, expansion=1, n_layers=[3, 4,  6, 3,1,1], name=&#39;xresnet34_deep&#39;)</span>
<span class="c1"># xresnet50_deep = partial(xresnet, expansion=4, n_layers=[3, 4,  6, 3,1,1], name=&#39;xresnet50_deep&#39;)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># def xresnet(expansion, n_layers, name, c_out=1000, pretrained=False, **kwargs):</span>
<span class="c1">#     model = XResNet(expansion, n_layers, c_out=c_out, **kwargs)</span>
<span class="c1">#     return model</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># def xresnet(expansion, n_layers, name, c_out=1000, pretrained=False, **kwargs):</span>
<span class="c1">#     return partial(XResNet, expansion, n_layers, c_out=c_out, **kwargs)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># xresnet50_d = xresnet(expansion=4, n_layers=[3, 4,  6, 3,1,1], name=&#39;xresnet50_deep&#39;)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># m = xresnet50_d(c_out=10)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># m.c_out</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # export</span>
<span class="c1"># me = sys.modules[__name__]</span>
<span class="c1"># for n,e,l in [</span>
<span class="c1">#     [ 18 , 1, [2,2,2 ,2] ],</span>
<span class="c1">#     [ 34 , 1, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 50 , 4, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 101, 4, [3,4,23,3] ],</span>
<span class="c1">#     [ 152, 4, [3,8,36,3] ],</span>
<span class="c1"># ]:</span>
<span class="c1">#     name = f&#39;xresnet{n}&#39;</span>
<span class="c1">#     setattr(me, name, xresnet(expansion=e, n_layers=l, name=name))</span>

<span class="c1"># xresnet18_deep = xresnet(expansion=1, n_layers=[2, 2,  2, 2,1,1], name=&#39;xresnet18_deep&#39;)</span>
<span class="c1"># xresnet34_deep = xresnet(expansion=1, n_layers=[3, 4,  6, 3,1,1], name=&#39;xresnet34_deep&#39;)</span>
<span class="c1"># xresnet50_deep = xresnet(expansion=4, n_layers=[3, 4,  6, 3,1,1], name=&#39;xresnet50_deep&#39;)</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># me = sys.modules[__name__]</span>
<span class="c1"># for n,e,l in [[ 18 , 1, [2,2,2 ,2] ],</span>
<span class="c1">#     [ 34 , 1, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 50 , 4, [3,4,6 ,3] ],</span>
<span class="c1">#     [ 101, 4, [3,4,23,3] ],</span>
<span class="c1">#     [ 152, 4, [3,8,36,3] ],]:</span>
<span class="c1">#     name = f&#39;net{n}&#39;</span>
<span class="c1">#     setattr(me, name, partial(XResNet, expansion=e, layers=l,))# name=name))</span>
</pre></div>

    </div>
</div>
</div>

</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="end">end<a class="anchor-link" href="#end">&#182;</a></h1><p>model_constructor
by ayasyrev</p>

</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># # hide</span>
<span class="c1"># from nbdev.export import *</span>
<span class="c1"># notebook2script()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}
</div>
 

